#!/usr/bin/env zsh

# requires fzf, jq and makeicns
# run: brew install fzf jq makeicns

zparseopts -D -E -F - \
  -process-all=process_all \
  -process-existing=process_existing \
  -favorites=favorites \
  -history=playhistory \
  {p,-playlist}:=playlist \
  {h,-help}=help || {
    print "see --help" >&2
    return 1
  }

if [[ -n $help ]]; then
cat <<- --------
HELP TEXT PLACEHOLDER!

Last argument should point to the directory where the shortcut.app will be created.
Defaults to the current working directory.

will process without fzf select mode.
  --process-all
  --process-existing  This will only overwrite existing shortcuts.

Playlists:
  --favorites
  --history
  -p, --playlist <path/to/playlist.lpl>

If no playlist argument is passed, fzf will list all of your playlists.

--------
  return
fi

output=${1:-.}

app_support=~/Library/Application\ Support/RetroArch
template=$0:h/template

function s.header {
  printf "\n\e[1;30m%s\e[0m\n" "${(j[ ])@}"
}
function s.error {
  printf "\e[0;31m%s\e[0m\n" "${(j[ ])@}"
}
function s.ok {
  printf "\e[0;32m%s\e[0m\n" "${(j[ ])@}"
}
function s.warn {
  printf "\e[0;33m%s\e[0m\n" "${(j[ ])@}"
}

if [[ -n $playlist ]]; then
  playlist=$playlist[-1]
elif [[ -n $favorites ]]; then
  favorites=$(eval printf `awk -F= '/content_favorites_path/ {print $2}' $app_support/config/retroarch.cfg`)
  playlist=${favorites/#\~/$HOME}
elif [[ -n $playhistory ]]; then
  playhistory=$(eval printf `awk -F= '/content_history_path/ {print $2}' $app_support/config/retroarch.cfg`)
  playlist=${playhistory/#\~/$HOME}
else
  playlistdir=$(eval printf `awk -F= '/playlist_directory/ {print $2}' $app_support/config/retroarch.cfg`)
  select=`for lpl in ${playlistdir/#\~/$HOME}/*.lpl; do echo $lpl:t:r; done | fzf`
  if [[ -n $select ]]; then
    playlist=${playlistdir/#\~/$HOME}/$select.lpl
  else
    s.warn Nothing selected.
    return
  fi
fi

if [[ ! -f $playlist ]]; then
  s.error Playlist does not exist:$playlist
  return 1
fi

limit=`jq -r ".items | length" $playlist`
cleanlist=$(
  for (( i=0; i!=$limit; i++ )); do
    # Scanning the history playlist can get spotty so check for .db_name.
    # If .db_name exists, everything else should exist.
    if [[ -n `jq -r ".items[$i].db_name" $playlist` ]]; then
      echo "$i\t`jq -r ".items[$i].label" $playlist`"
    fi
  done
)

if [[ -n ${process_all:-$process_existing} ]]; then
  working_indices=( `print $cleanlist | cut -f1` )
else
  working_indices=( `print $cleanlist | fzf --multi --delimiter='\t' --with-nth=2 | cut -f1` )
fi

if [[ -z $working_indices ]]; then
  s.warn Nothing to process.
  return
fi

IFS=$'\n'
for i in $working_indices; do
  read -d '' system label gpath cpath < <(
    jq -r ".items[$i] | .db_name, .label, .path, .core_path" $playlist
  )
  system=${system:r}

  # Make label file system safe.
  # - replace ':' with ','
  # - replace '/' with '-'.
  shortcutapp=$output/${${label//:/,}//\//-}.app

  if [[ -n $process_existing ]] && [[ ! -d $shortcutapp ]]; then
    continue
  fi

  s.header Creating \"$shortcutapp:t\"

  mkdir -p $shortcutapp
  if ! cp -R $template/Contents $shortcutapp; then
    s.error Could not create \"$shortcutapp:t\".
    continue
  fi

  # Custom thumbnails
  # https://docs.libretro.com/guides/roms-playlists-thumbnails/#custom-thumbnails
  #
  # RetroArch will attempt up to 3 different match techniques to associate a playlist
  # item with a local thumbnail image file, in the following order:
  #
  # 1. ROM file name <-> .png file name match.
  # 2. Game name <-> .png file name match.
  # 3. Short game name <-> .png file name match.
  #
  # - Replace '&*/:`<>?\|' with '_'.
  # - $gpath may point inside an archive with '#'. Cut extension twice `:r:r` to clear it.
  thumbnames=(
    ${gpath:t:r:r}
    $label
    ${${gpath:t:r:r}// \(*}
    ${label// \(*}
  )

  thumbfound=0
  icnpath=$shortcutapp/Contents/Resources/shortcut.icns
  for set in Boxarts Titles Snaps; do
    for thumb in $thumbnames; do
      thumb=`printf $thumb | tr '&*/:\`<>?\|' '_'`
      thumbpath=$app_support/thumbnails/$system/Named_$set/$thumb.png
      if [[ -f $thumbpath ]]; then
        thumbfound=1
        s.ok "$set/$thumb.png -> $icnpath:t"
        makeicns -in $thumbpath -out $icnpath
        break 2
      fi
    done
  done

  # Use RetroSystem XMB theme content icon as a fallback.
  if ! (( $thumbfound )); then
    fallback=$app_support/assets/xmb/retrosystem/png/$system-content.png
    if [[ -f $fallback ]]; then
      s.ok "retrosystem/$system-content.png -> $icnpath:t"
      makeicns -in $fallback -out $icnpath
    else
      s.warn Using the default $icnpath:t file.
    fi
  fi

  # Clear all metadata which could prevent code signing.
  xattr -c $icnpath

  # Limit application bundle id to alphanumerics.
  bundleid=libretro.RetroArch
  for s in $system $label; bundleid+=.`printf $s | tr -cd '[:alnum:]'`
  if plutil -replace CFBundleIdentifier -xml $bundleid $shortcutapp/Contents/info.plist; then
    s.ok BundleID: $bundleid
  else
    s.error BundleID not set.
  fi

  runnable=0
  if [[ -f ${gpath//\#*} ]]; then
    sed -i '' -E "s:<GAME_PATH>:$gpath:" $shortcutapp/Contents/MacOS/launcher
    s.ok gamepath: $gpath

    for _cpath in $cpath `jq -r ".default_core_path" $playlist`; do
      if [[ -f $_cpath ]]; then
        sed -i '' -E "s:<CORE_PATH>:$_cpath:" $shortcutapp/Contents/MacOS/launcher
        s.ok corepath: $_cpath
        runnable=1
        break
      fi
    done
  fi

  if ! (( $runnable )); then
    s.error Error assigning paths.
    continue
  fi

  chmod +x $shortcutapp/Contents/MacOS/launcher

  codesign --sign - $shortcutapp

done
