#!/usr/bin/env zsh

# requires fzf, jq and makeicns

zparseopts -D -E -F - \
  -process-all=process_all \
  -process-existing=process_existing \
  -favorites=favorites \
  -history=playhistory \
  {p,-playlist}:=playlist \
  {t,-template}:=template \
  {h,-help}=help || {
    print "see --help" >&2
    return 1
  }

if [[ -n $help ]]; then
cat <<- --------
usage: rashortcuts [OPTION]... [OUTPUT]

Playlists:
  --favorites         favorites playlist
  --history           history playlist
  -p, --playlist      path/to/playlist.lpl

If a playlist is not provided, fzf will list them automatically.

Process without fzf game selection.
  --process-all       process all entries for a given playlist
  --process-existing  re-process existing shortcuts in the working path

Last argument should point to the directory where the shortcut.app will be created.
Defaults to the current working directory.

Custom templates:
  -t, --template      path/to/template-folder

An optional template for building shortcuts. It defaults to the folder named
"template" located in the same directory as this script.

  -h, --help          view help.

--------
return
fi

s.header(){ printf "\n\e[1;30m%s\e[0m\n" $@ }
s.ok()    { printf "\e[0;32m%s\e[0m\n" $@ }
s.warn()  { printf "\e[0;33m%s\e[0m\n" $@ }
s.error() { printf "\e[0;31m%s\e[0m\n" $@ >&2 }

output=${1:-.}

app_support=~/Library/Application\ Support/RetroArch
# Ensure the default template is located with this script.
template=${template[-1]:-$(dirname `realpath $0`)/template}

if [[ ! -d $template/Contents/MacOS ]]; then
  s.error "Template does not exist or is not valid: $template"
  return 1
fi

if [[ -n $playlist ]]; then
  playlist=$playlist[-1]
elif [[ -n $favorites ]]; then
  favorites=$(eval printf %s $(
    awk -F= '/content_favorites_path/ {print $2}' $app_support/config/retroarch.cfg
  ))
  playlist=${favorites/#\~/$HOME}
elif [[ -n $playhistory ]]; then
  playhistory=$(eval printf %s $(
    awk -F= '/content_history_path/ {print $2}' $app_support/config/retroarch.cfg
  ))
  playlist=${playhistory/#\~/$HOME}
else
  playlistdir=$(eval printf %s $(
    awk -F= '/playlist_directory/ {print $2}' $app_support/config/retroarch.cfg
  ))
  select=$(
    for lpl in ${playlistdir/#\~/$HOME}/*.lpl; do echo $lpl:t:r; done | fzf
  )
  if [[ -n $select ]]; then
    playlist=${playlistdir/#\~/$HOME}/$select.lpl
  else
    s.warn "Nothing selected."
    return
  fi
fi

if [[ ! -f $playlist ]]; then
  s.error "Playlist does not exist: $playlist"
  return 1
fi

limit=`jq -r ".items | length" $playlist`
cleanlist=$(
  for (( i=0; i!=$limit; i++ )); do
    # Scanning the history playlist can get spotty so check for .db_name.
    # If .db_name exists, everything else should exist.
    if [[ -n `jq -r ".items[$i].db_name" $playlist` ]]; then
      echo "$i\t`jq -r ".items[$i].label" $playlist`"
    fi
  done
)

if [[ -n ${process_all:-$process_existing} ]]; then
  working_indices=( `print $cleanlist | cut -f1` )
else
  working_indices=(
    `print $cleanlist | fzf --multi --delimiter='\t' --with-nth=2 | cut -f1`
  )
fi

if [[ -z $working_indices ]]; then
  s.warn "Nothing to process."
  return
fi

app_dir=`mdfind kMDItemCFBundleIdentifier = com.libretro.dist.RetroArch | head -n 1`
if [[ -n $app_dir ]]; then
  app_info=$app_dir/Contents/Info.plist
  app_ver=`plutil -extract CFBundleShortVersionString raw $app_info`
  min_ver=`plutil -extract LSMinimumSystemVersion raw $app_info`
else
  s.error "RetroArch not found."
  return 1
fi

default_cname=`jq -r ".default_core_name" $playlist`
default_cpath=`jq -r ".default_core_path" $playlist`

IFS=$'\n'
for i in $working_indices; do
  read -d '' system label gpath cname cpath < <(
    jq -r ".items[$i] | .db_name, .label, .path, .core_name, .core_path" $playlist
  )
  system=${system:r}
  cname=${${cname/DETECT}:-$default_cname}
  cpath=${${cpath/DETECT}:-$default_cpath}

  # Make label file system safe.
  # - replace ':' with ','
  # - replace '/' with '-'.
  shortcut_app=$output/${${label//:/,}//\//-}.app

  if [[ -n $process_existing ]] && [[ ! -d $shortcut_app ]]; then
    continue
  fi

  s.header "Creating \"$shortcut_app:t\""

  mkdir -p $shortcut_app
  if ! cp -R $template/Contents $shortcut_app; then
    s.error "Could not create \"$shortcut_app:t\"."
    continue
  fi

  shortcut_info=$shortcut_app/Contents/info.plist
  plutil -insert CFBundleDisplayName -string $label $shortcut_info
  plutil -insert CFBundleShortVersionString -string $app_ver $shortcut_info
  plutil -insert LSMinimumSystemVersion -string $min_ver $shortcut_info
  # plutil -insert NSHumanReadableCopyright -string $copyright $shortcut_info
  # plutil -insert LSEnvironment -string $env_vars $shortcut_info

  # gpathextended: full path including possible archive content.
  # gpath: game path without the archive content pointers.
  # fname: name of the file itself.
  # aname: name of archive content. Empty if not present.
  # label: name from database.

  unset match
  [[ $gpath:t =~ "(.*\.[[:alnum:]]{2,3})\#(.*)\.[[:alnum:]]{2,4}$" ]]
  gpathextended=$gpath
  gpath=$gpath:h/${match[1]:-$gpath:t}
  fname=$gpath:t:r
  aname=$match[2]

  # short core name
  unset match
  [[ $cpath:t =~ "(.*)_libretro.dylib" ]]
  scname=$match[1]

  # Limit application bundle id to alphanumerics.
  bundleid=com.libretro
  for s in $scname $fname; bundleid+=.`printf %s $s | tr -cd '[:alnum:]'`
  if [[ -n $scname ]] && \
      plutil -insert CFBundleIdentifier -string $bundleid $shortcut_info
  then
    s.ok "BundleID: $bundleid"
  else
    s.error "BundleID not set."
  fi

  runnable=0
  if [[ -f $gpath ]]; then
    sed -i '' -E "s:#GAME#:$gpathextended:" $shortcut_app/Contents/MacOS/launcher && \
      s.ok "Game: $gpathextended:t"

    # Use simplified naming instead of fragile paths.
    if [[ -n $scname ]]; then
      sed -i '' -E "s:#CORE#:$scname:" $shortcut_app/Contents/MacOS/launcher && \
        s.ok "Core: $cname" && \
        runnable=1
    else
      s.error "The core could not be determined from the playlist. Do one of the following:"
      s.error "- Set a default core for the playlist. (recommended)"
      s.error "- Run the game in RetroArch at least once from the playlist."
    fi
  fi

  if ! (( $runnable )); then
    s.error "Error assigning game path or core id."
    continue
  fi

  typeset -aU thumbnames=(
    $fname
    $aname
    $label
  )

  # For each name in $thumbnames:
  # - Chop off each occurance of `(.*)` or `[.*]` from the trailing end.
  # - Add each iteration to the list of naming candidates.
  for _name in $thumbnames; do
    while [[ $_name =~ "^(.+)(\(|\[)([^([]*)(\)|\]).*$" ]]; do
      _name=$match[1]
      # Discard trailing spaces.
      thumbnames+=${_name%${_name##*[! ]}}
    done
  done

  thumbfound=0
  icnpath=$shortcut_app/Contents/Resources/AppIcon.icns
  for set in Boxarts Titles Snaps; do
    for thumb in $thumbnames; do
      # Mimic RetroArch's safe naming for thumbnails.
      thumb=`printf %s $thumb | tr '&*/:\`<>?\|' '_'`
      thumbpath=$app_support/thumbnails/$system/Named_$set/$thumb.png
      if [[ -f $thumbpath ]]; then
        thumbfound=1
        s.ok "$set/$thumb.png -> $icnpath:t"
        makeicns -align bottom -in $thumbpath -out $icnpath
        break 2
      fi
    done
  done

  # Use RetroSystem XMB theme content icon as a fallback.
  if ! (( $thumbfound )); then
    fallback=$app_support/assets/xmb/retrosystem/png/$system-content.png
    if [[ -f $fallback ]]; then
      s.ok "retrosystem/$system-content.png -> $icnpath:t"
      makeicns -align bottom -in $fallback -out $icnpath
    else
      s.warn Using the default $icnpath:t file.
    fi
  fi

  chmod +x $shortcut_app/Contents/MacOS/launcher

  codesign --force --sign - $shortcut_app

done
